(window.webpackJsonp=window.webpackJsonp||[]).push([[84],{481:function(e,_,v){"use strict";v.r(_);var o=v(56),t=Object(o.a)({},(function(){var e=this,_=e.$createElement,v=e._self._c||_;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("h1",{attrs:{id:"整体思路"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#整体思路"}},[e._v("#")]),e._v(" 整体思路")]),e._v(" "),v("p",[v("strong",[e._v("Vue2 通过降低 Watcher 的粒度，一个组件对应一个 Watcher (渲染Watcher)来解决Vue1 Watcher 太多导致的资源占用过多，性能下降问题")]),e._v("。")]),e._v(" "),v("p",[e._v("在 Vue1 中，Watcher 和页面中的响应式数据一一对应，当响应式数据发生改变，Dep 通知 Watcher 完成对应的 DOM 更新。但是在 Vue2 中一个组件对应一个 Watcher，当响应式数据发生改变时，Watcher并不知道这个响应式数据在组件中的什么位置，那又该如何完成更新呢？")]),e._v(" "),v("p",[e._v("答案是：Vue2 引入了 VNode 和 diff 算法，将组件编泽成VNode，每次响应式数据发生变化时，会生成新的 VNode，通过 diff 算法对比新旧 VNode，找出其中发生改变的地方，然后执行对应的 DOM 操作完成更新。")]),e._v(" "),v("p",[e._v("所以，"),v("strong",[e._v("Vue1和Vue2在核心的数据响应式部分其实没什么变化，主要的变动在编译器部分")]),e._v("。")]),e._v(" "),v("p",[e._v("编译的主要流程是这样的：")]),e._v(" "),v("ul",[v("li",[v("p",[v("strong",[e._v("1. 通过执行"),v("code",[e._v("renderHelper")]),e._v("在 vue 实例上挂载 "),v("code",[e._v("_c")]),e._v("、"),v("code",[e._v("_v")]),e._v("、"),v("code",[e._v("_s")]),e._v("等方法")])]),e._v(" "),v("p",[e._v("其中"),v("code",[e._v("_c")]),e._v(" 用于生成元素节点的 vnode，"),v("code",[e._v("_v")]),e._v("用于生成文本节点的 vnode 。")])]),e._v(" "),v("li",[v("p",[v("strong",[e._v("2. 在 vue 实例上挂载 "),v("code",[e._v("__patch__")]),e._v("方法")])])])]),e._v(" "),v("p",[v("code",[e._v("__patch__")]),e._v("方法接收新旧 vnode, 用于生成真实 dom 。")]),e._v(" "),v("ul",[v("li",[v("p",[v("strong",[e._v("3. 在 vue 原型链上定义"),v("code",[e._v("$mount")]),e._v("方法")])]),e._v(" "),v("p",[v("code",[e._v("$mount")]),e._v("方法主要做了两件事：")]),e._v(" "),v("ol",[v("li",[e._v("生成渲染函数 render,并将 render 挂载到 $option 上，"),v("code",[e._v("vm.$options.render = render")]),e._v("。")])]),e._v(" "),v("blockquote",[v("p",[e._v("这个过程是先将模板解析成 ast, 再将 ast 转化成渲染函数的字符串形式，通过 "),v("code",[e._v("new Function")]),e._v(" 将字符串变成可执行函数。")])]),e._v(" "),v("ol",{attrs:{start:"2"}},[v("li",[e._v("调用"),v("code",[e._v("mountComponent(vm)")]),e._v("，实例化一个渲染 Watcher，进行组件的初始化渲染和后续更新。")])]),e._v(" "),v("blockquote",[v("p",[e._v("这个过程具体是这样的："),v("code",[e._v("mountComponent")]),e._v("函数中实例化一个渲染 Watcher，初始化渲染（即new Watcher 的时候）或响应式数据更新时，都会执行Watcher里的回调函数，回调函数中执行"),v("code",[e._v("vm._update(vm._render())")]),e._v("方法，"),v("code",[e._v("vm._render()")]),e._v("即是执行之前挂载到 $option 上的 render 方法，生成新vnode， "),v("code",[e._v("vm._update")]),e._v("接收render函数生成的新vnode, 并将新旧vnode都传给"),v("code",[e._v("__patch__")]),e._v("函数用于更新dom。")])])])])])}),[],!1,null,null,null);_.default=t.exports}}]);